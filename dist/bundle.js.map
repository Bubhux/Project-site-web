{"version":3,"file":"bundle.js","mappings":";;UAAA;UACA;;;;;WCDA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,cAAc,cAAc;AAC5B,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,6BAA6B;AACxC,WAAW,sBAAsB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL","sources":["webpack://projet-html-css-sass/webpack/bootstrap","webpack://projet-html-css-sass/webpack/runtime/make namespace object","webpack://projet-html-css-sass/./js/main.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// js/main.js\r\n\r\n\r\n/**\r\n * @fileoverview IntersectionObserver pour déclencher l'apparition des éléments avec animation lorsque\r\n * ils entrent dans le viewport. Le code ajoute également la classe `loaded` au corps du document après le chargement de la page.\r\n */\r\n\r\n/**\r\n * Ratio utilisé pour déterminer le seuil d'intersection.\r\n * @constant {number}\r\n */\r\nconst ratio = 0.1\r\n\r\n/**\r\n * Options pour l'IntersectionObserver.\r\n * @constant {Object}\r\n * @property {Element|null} root - Élément racine pour l'observation (null pour viewport).\r\n * @property {string} rootMargin - Marge autour du root.\r\n * @property {number} threshold - Seuil d'intersection, déclenche à 10% visible.\r\n */\r\nconst options = {\r\n    root: null,\r\n    rootMargin: '0px',\r\n    threshold: ratio\r\n}\r\n\r\n/**\r\n * Callback appelée lorsque les éléments observés intersectent le viewport.\r\n * Ajoute la classe 'reveal-visible' aux éléments visibles et les retire de l'observation.\r\n *\r\n * @param {IntersectionObserverEntry[]} entries - Liste des entrées observées.\r\n * @param {IntersectionObserver} observer - Instance de l'IntersectionObserver.\r\n */\r\nconst handleIntersect = function (entries, observer) {\r\n    entries.forEach(function (entry) {\r\n        if (entry.isIntersecting) {\r\n            // Ajoute la classe 'reveal-visible' si l'élément est visible dans le viewport\r\n            entry.target.classList.add('reveal-visible')\r\n            // Arrête d'observer l'élément une fois qu'il est visible\r\n            observer.unobserve(entry.target)\r\n        }\r\n    })\r\n}\r\n\r\n/**\r\n * Fonction exécutée lorsque la page est entièrement chargée.\r\n * Ajoute la classe 'loaded' au corps du document et initialise l'observateur pour tous les éléments\r\n * dont la classe contient 'reveal-'.\r\n */\r\nwindow.onload = function () {\r\n    // Ajoute la classe 'loaded' au body après le chargement complet de la page\r\n    document.body.classList.add('loaded')\r\n\r\n    // Crée une nouvelle instance d'IntersectionObserver avec la fonction de callback `handleIntersect`\r\n    const observer = new IntersectionObserver(handleIntersect, options)\r\n\r\n    // Sélectionne tous les éléments dont la classe contient 'reveal-' et les observe\r\n    document.querySelectorAll('[class*=\"reveal-\"]').forEach(function (r) {\r\n        observer.observe(r)\r\n    })\r\n}\r\n"],"names":[],"sourceRoot":""}